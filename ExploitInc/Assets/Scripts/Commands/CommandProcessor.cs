
using System;
using UnityEngine;
using Zenject;

namespace SBaier.ExploitInc
{
	public abstract class CommandProcessor<TCommands> : MonoBehaviour where TCommands : CommandsContainer
	{
		private TCommands _commands;
		private CommandSequence _currentSequence;
		private int _sequenceIndex = -1;

		[Inject]
		private void Construct(TCommands commands)
		{
			_commands = commands;
		}

		protected virtual void Start()
		{
			_commands.OnCurrentCommandChanged += onCurrentCommandChanged;
			if (_commands.Current != null)
				process(_commands.Current);
		}

		protected virtual void OnDestroy()
		{
			_commands.OnCurrentCommandChanged -= onCurrentCommandChanged;
		}

		private void onCurrentCommandChanged(CommandsContainer.CommandChangedArgs args)
		{
			if (args.Former != null)
				clean(args.Former);
			if (args.Current != null)
				process(args.Current);
		}

		private void clean(Command command)
		{
			command.OnStateChanged -= onStateChanged;
		}

		private void process(Command command)
		{
			command.State = CommandState.OnGoing;
			command.OnStateChanged += onStateChanged;
			if (command is CommandSequence)
				processSequence((CommandSequence)command);
			else
				processSingle(command);
		}

		private void processSequence(CommandSequence sequence)
		{
			_currentSequence = sequence;
			_currentSequence.State = CommandState.OnGoing;
			processNextInSequence();
		}

		internal abstract void processSingle(Command command);

		private void onStateChanged(Command.StateChangeArgs obj)
		{
			if (obj.NewState != CommandState.Canceled && obj.FormerState == CommandState.OnGoing)
				return;

			stopProcess(obj.Command);
		}

		private void stopProcess(Command command)
		{
			bool isSequence = command is CommandSequence;
			if (isSequence)
				stopCurrentSequence();
			else
				stopSingleProcess(command);
		}

		internal abstract void stopSingleProcess(Command command);

		private void stopCurrentSequence()
		{
			if (_currentSequence.State == CommandState.Finished)
				return;

			stopSingleProcess(_currentSequence.CommandsCopy[_sequenceIndex]);
			_currentSequence.CommandsCopy[_sequenceIndex].OnStateChanged -= onSequenceStateChanged;
			cleanSequence();
		}

		private void processNextInSequence()
		{
			if (_currentSequence == null)
				throw new InvalidOperationException();
			if (_sequenceIndex >= _currentSequence.Count)
				throw new InvalidOperationException();

			_sequenceIndex++;
			if(_sequenceIndex >= _currentSequence.Count)
			{
				CommandSequence current = _currentSequence;
				cleanSequence();
				current.State = CommandState.Finished;
			}
			else
			{
				_currentSequence.CommandsCopy[_sequenceIndex].OnStateChanged += onSequenceStateChanged;
				processSingle(_currentSequence.CommandsCopy[_sequenceIndex]);
			}
		}

		private void onSequenceStateChanged(Command.StateChangeArgs obj)
		{
			if (obj.NewState != CommandState.Finished && obj.FormerState == CommandState.OnGoing)
				return;

			obj.Command.OnStateChanged -= onSequenceStateChanged;
			processNextInSequence();
		}

		private void cleanSequence()
		{
			_currentSequence = null;
			_sequenceIndex = -1;
		}
	}
}