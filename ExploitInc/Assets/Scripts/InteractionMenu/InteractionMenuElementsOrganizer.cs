using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace SBaier.ExploitInc
{
	public class InteractionMenuElementsOrganizer : MonoBehaviour
	{
		private const float _elementShowAnimationTime = 0.25f;

		[SerializeField]
		private Transform _elementHook = null;
		[SerializeField]
		private float _showTime = 0.33f;
		[SerializeField]
		private CanvasGroup _group = null;
		[SerializeField]
		private float _hideTime = 0.5f;
		[SerializeField]
		private float _deltaAngle = 45;
		[SerializeField]
		private float _startAngle = 20;
		[SerializeField]
		private bool _reverse = true;

		private bool _shown = false;
		private Coroutine _activeShowRoutine = null;
		private Coroutine _activeHideRoutine = null;

		private List<InteractionMenuElement> _elements = new List<InteractionMenuElement>();

		public event Action OnHidden;


		protected virtual void Awake()
		{
			activateGroup(false);
		}

		protected virtual void OnEnable()
		{
			reorder();
		}

		public void Show()
		{
			if (_activeHideRoutine != null ||
				_shown || _activeShowRoutine != null)
				return;

			activateGroup(true);
			_shown = true;
			_activeShowRoutine = StartCoroutine(show());
		}

		private IEnumerator show()
		{
			float deltaTime = _elements.Count > 0 ? _showTime / _elements.Count : 0;
			foreach (InteractionMenuElement element in _elements)
			{
				element.Show();
				yield return new WaitForSeconds(deltaTime);
			}
			yield return new WaitForSeconds(_elementShowAnimationTime);
			_activeShowRoutine = null;
		}

		public void Hide()
		{
			if (_activeHideRoutine != null || !_shown)
				return;

			if (_activeShowRoutine != null)
				StopCoroutine(_activeShowRoutine);

			_shown = false;
			_group.interactable = false;
			_activeHideRoutine = StartCoroutine(hide());
		}

		private IEnumerator hide()
		{
			foreach (InteractionMenuElement element in _elements)
				element.Hide();
			yield return new WaitForSeconds(_hideTime);
			activateGroup(false);
			_activeHideRoutine = null;
			OnHidden?.Invoke();
		}

		public void AddElement(InteractionMenuElement element)
		{
			_elements.Add(element);
			element.Base.SetParent(_elementHook, false);
			if (_shown)
				element.Show();
			reorder();
		}

		public void RemoveElement(InteractionMenuElement element)
		{
			if (!_elements.Contains(element))
				return;
			element.Hide();
			element.Base.SetParent(null);
			_elements.Remove(element);
			reorder();
		}

		private void reorder()
		{
			int count = _elements.Count;
			if (count == 0)
				return;
			float deltaAngle = _deltaAngle;
			for (int i = 0; i < count; i++)
			{
				InteractionMenuElement element = _elements[i];
				float targetRot = (deltaAngle * i + _startAngle) / 360;
				if (_reverse)
					targetRot = 1 - targetRot;
				element.RotateTo(targetRot);
			}
		}

		private void activateGroup(bool activate)
		{
			_group.interactable = activate;
			_group.alpha = activate ? 1 : 0;
			_group.blocksRaycasts = activate;
		}
	}
}