using System;
using System.Collections.Generic;
using UnityEngine;

namespace SBaier.ExploitInc
{
	[RequireComponent(typeof(Collider))]
	public class BlockingRadius : MonoBehaviour
	{
		[SerializeField]
		private bool _enableOnStart = false;

		private List<Blockable> _blockingObjects = new List<Blockable>();
		public bool Blocked => _blockingObjects.Count > 0 && _doBlock;

		[SerializeField]
		private Blockable _objectToPlace = null;
		public event Action OnBlockedChanged;

		private bool _doBlock = false;
		public bool DoBlock
		{
			get => _doBlock;
			set
			{
				_doBlock = value;
				checkEnableBlock();
			}
		}


		protected virtual void Awake()
		{
			DoBlock = _enableOnStart;
		}

		protected virtual void OnDestroy()
		{
			foreach (Blockable blockable in _blockingObjects)
				blockable.Unblock();
		}

		protected virtual void OnTriggerEnter(Collider other)
		{
			Blockable blockable = other.GetComponentInChildren<Blockable>();
			if (blockable == null || blockable == _objectToPlace || _blockingObjects.Contains(blockable))
				return;
			bool former = Blocked;
			if (DoBlock)
				blockable.Block();
			_blockingObjects.Add(blockable);
			checkBlocked(former);
		}

		protected virtual void OnTriggerExit(Collider other)
		{
			Blockable blockable = other.GetComponentInChildren<Blockable>();
			if (blockable == null)
				return;
			bool former = Blocked;
			if (DoBlock)
				blockable.Unblock();
			_blockingObjects.Remove(blockable);
			checkBlocked(former);
		}


		private void checkBlocked(bool formerState)
		{
			if (formerState == Blocked)
				return;
			_objectToPlace.Block(Blocked);
			OnBlockedChanged?.Invoke();
		}


		private void checkEnableBlock()
		{
			bool former = Blocked;
			foreach (Blockable blockable in _blockingObjects)
				blockable.Block(DoBlock);
			checkBlocked(former);
		}
	}
}