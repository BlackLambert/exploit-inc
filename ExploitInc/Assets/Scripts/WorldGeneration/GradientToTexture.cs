using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.Assertions;

namespace SBaier.ExploitInc
{
    public class GradientToTexture 
    {
        private readonly int _textureResolution;

        public GradientToTexture(int textureResolution)
		{
            _textureResolution = textureResolution;

        }

        public Texture2D Convert(Gradient gradient)
		{
            Texture2D result = new Texture2D(_textureResolution, 1);
            Color[] colors = new Color[_textureResolution];
			for (int i = 0; i < _textureResolution; i++)
			{
                colors[i] = gradient.Evaluate(i / (_textureResolution - 1f));
            }
            result.SetPixels(colors);
            result.Apply();
            byte[] png = result.EncodeToPNG();
            File.WriteAllBytes(Application.persistentDataPath + "/Gradient.png", png);
            return result;
        }

        public Texture2D Convert(List<GradientTexture2DArg> args)
		{
            Assert.IsTrue(args != null && args.Count > 0);
            float range = args.Sum(a => a.Size);
            GradientTexture2DArg currentArg = args[0];
            GradientTexture2DArg nextArg = args.Count > 1 ? args[1] : null;
            int argIndex = 0;
            float nextArgsBorder = currentArg.Size - currentArg.Offset / 2;
            float offsetY = nextArgsBorder + currentArg.Offset;
            float currentY = 0;

            Texture2D result = new Texture2D(_textureResolution, _textureResolution);
            float step = 1f / _textureResolution;
            float yStep = step * range;


            for (int i = 0; i < _textureResolution; i++)
			{
                for (int j = 0; j < _textureResolution; j++)
				{
                    Color currentBiomColor = currentArg.Colors.Evaluate(j / (_textureResolution - 1f));
                    Color nextBiomColor = nextArg != null ? nextArg.Colors.Evaluate(j / (_textureResolution - 1f)) : currentBiomColor;
                    float t = (Mathf.Clamp(currentY, nextArgsBorder, offsetY) - nextArgsBorder) / currentArg.Offset;
                    Color pixelColor = Color.Lerp(currentBiomColor, nextBiomColor, t);
                    result.SetPixel(j, i, pixelColor);
                }
                currentY+= yStep;

                if(nextArg != null &&(currentY >= offsetY || currentY >= nextArgsBorder + nextArg.Size))
				{
                    argIndex++;
                    currentArg = nextArg;
                    nextArg = argIndex + 1 < args.Count ? args[argIndex+ 1] : null;
                    nextArgsBorder += currentArg.Size - currentArg.Offset / 2;
                    offsetY = nextArgsBorder + currentArg.Offset;
                }
            }
            result.Apply();
            byte[] png = result.EncodeToPNG();
            File.WriteAllBytes(Application.persistentDataPath + "/Screenshot.png", png);
            return result;
        }

        public class GradientTexture2DArg
		{
            public float Offset { get; } = 0;
            public float Size { get; } = 1f;
            public Gradient Colors { get; }

            public GradientTexture2DArg(float offset, float size, Gradient colors)
			{
                Assert.IsTrue(offset > 0);
                Assert.IsTrue(size > 0);
                Offset = offset;
                Size = size;
                Colors = colors;
            }
        }
    }
}