using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Zenject;

namespace SBaier.ExploitInc
{
	public abstract class DeliveryContainer : MonoBehaviour
	{
		[SerializeField]
		private Transform _base = null;
		public Transform Base => _base;

		[SerializeField]
		private Transform _point = null;
		public Transform Point => _point;

		public Transform Host { get; set; }

		public Guid Id { get; private set; }

		private List<Deliverable> _availableDeliverables = new List<Deliverable>();
		private List<Deliverable> _reservedDeliverables = new List<Deliverable>();
		private List<Deliverable> _promisedDeliverables = new List<Deliverable>();

		public List<Deliverable> AvailableDeliverablesCopy => new List<Deliverable>(_availableDeliverables);
		public List<Deliverable> StoredDeliverablesCopy
		{ 
			get
			{
				List<Deliverable> result = new List<Deliverable>(_availableDeliverables);
				result.AddRange(_reservedDeliverables);
				return result;
			}
		}

		public int Count => _availableDeliverables.Count + _reservedDeliverables.Count + _promisedDeliverables.Count;
		public int StoredCount => _availableDeliverables.Count + _reservedDeliverables.Count;
		public int AvailableCount => _availableDeliverables.Count;
		public int PromisedCount => _promisedDeliverables.Count;
		public bool Empty => Count == 0;
		public bool Full => SpaceLeft == 0;
		public abstract int SpaceLeft { get; }

		public Sprite Sprite { get; private set; }

		public event Action OnStoredChanged;
		public event Action<Deliverable> OnDelivarableAdded;
		public event Action<Deliverable> OnDeliverableRemoved;


		[Inject]
		private void Construct(Guid id,
			Sprite sprite)
		{
			Id = id;
			Sprite = sprite;
		}


		public void Reserve(Deliverable deliverable)
		{
			if (AvailableCount == 0 || !_availableDeliverables.Contains(deliverable))
				throw new InvalidOperationException();
			_availableDeliverables.Remove(deliverable);
			_reservedDeliverables.Add(deliverable);
		}

		public Deliverable ReserveAny()
		{
			if (_availableDeliverables.Count == 0)
				throw new InvalidOperationException();
			Deliverable last = _availableDeliverables[_availableDeliverables.Count - 1];
			Reserve(last);
			return last;
		}

		public void CancelReservationOf(Deliverable deliverable)
		{
			if (_reservedDeliverables.Count == 0 || !_reservedDeliverables.Contains(deliverable))
				throw new InvalidOperationException();
			_availableDeliverables.Add(deliverable);
			_reservedDeliverables.Remove(deliverable);
		}

		public void Promise(Deliverable deliverable)
		{
			if (!promisePossible())
				throw new InvalidOperationException();
			_promisedDeliverables.Add(deliverable);
		}

		public void CancelPromiseOf(Deliverable deliverable)
		{
			if (_promisedDeliverables.Count == 0 || !_promisedDeliverables.Contains(deliverable))
				throw new InvalidOperationException();
			_promisedDeliverables.Remove(deliverable);
		}

		public void Store(Deliverable deliverable)
		{
			if (_promisedDeliverables.Count == 0 || !_promisedDeliverables.Contains(deliverable))
				throw new InvalidOperationException("This deliverable has not been promised before. Please promise before storing");
			_promisedDeliverables.Remove(deliverable);
			_availableDeliverables.Add(deliverable);
			OnStoredChanged?.Invoke();
			OnDelivarableAdded?.Invoke(deliverable);
		}

		public void Take(Deliverable deliverable)
		{
			if (_reservedDeliverables.Count == 0 || !_reservedDeliverables.Contains(deliverable))
				throw new InvalidOperationException("This deliverable has not been reserved before. Please reserve before storing");
			_reservedDeliverables.Remove(deliverable);
			OnStoredChanged?.Invoke();
			OnDeliverableRemoved?.Invoke(deliverable);
		}

		protected abstract bool promisePossible();
	}
}