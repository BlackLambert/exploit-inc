using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Zenject;

namespace SBaier.ExploitInc
{
	public class MovablePlanetObject : MonoBehaviour
	{
		[SerializeField]
		private float _speed = 0.1f;
		//[SerializeField]
		//private float _rotationSpeed = 1f;
		[SerializeField]
		private Transform _base = null;
		[SerializeField]
		private Transform _center = null;

		//private float CenterDistance { get { return (_base.position - _center.position).magnitude; } }

		//private Vector3 CurrentLookDirection { get { return _base.forward; } }
		private Vector3 CurrentPos { get { return _base.position; } }
		private Vector3 TargetDistance { get { return TargetPos - _base.position; } }

		//private float _rotationGap = 0;
		private Quaternion _targetCenterRotation;
		private Vector3 _formerPos;


		public Vector3 TargetPos 
		{
			get { return _targetPos; }
			set
			{
				_targetPos = value;
				//_rotationGap = calculateRotationGap();
				_targetCenterRotation = getTargetRotation();
			}
		}
		private Vector3 _targetPos;

		//private bool Rotating { get { return _rotationGap != 0; } }
		private bool Moving { get { return _targetCenterRotation != _center.rotation; } }
		


		/*[Inject]
		private void Construct(Transform center)
		{
			_center = center;
		}*/

		protected virtual void Start()
		{
			_targetPos = CurrentPos;
			_targetCenterRotation = _center.rotation;
			_formerPos = _base.position;
		}

		protected virtual void Update()
		{
			lookAlongMoveDirection();
			_formerPos = _base.position;
		}

		protected virtual void FixedUpdate()
		{
			//if (Rotating)
			//	rotate();
			//else if (Moving)
			if (Moving)
				move();
		}

		/*private void rotate()
		{
			float delta;
			if (Mathf.Abs(_rotationGap) <= _rotationSpeed)
				delta = _rotationGap;
			else
				delta = _rotationGap > 0 ? _rotationSpeed : -_rotationSpeed;

			Vector3 euler = _base.localRotation.eulerAngles;
			float yRot = euler.y + delta;
			_base.localRotation = Quaternion.Euler(euler.x, yRot, euler.z);
			_rotationGap -= delta;
		}*/

		private void lookAlongMoveDirection()
		{
			if (_formerPos == _base.position)
				return;

			Vector3 forward = _base.position - _formerPos;
			_base.rotation = Quaternion.LookRotation(forward, _base.up);
			//Debug.Log($"{forward} | {_base.localRotation.eulerAngles}");
		}

		private void move()
		{
			_center.rotation = Quaternion.RotateTowards(_center.rotation, _targetCenterRotation, _speed);
			//Debug.Log($" {_center.rotation} | {_targetRotation}");
		}

		/*private float calculateRotationGap()
		{
			float gap = Vector3.Angle(calculateTargetRot(), CurrentLookDirection);
			if (Vector3.Dot(_base.right, TargetPos) < 0)
				gap *= -1;
			return gap;
		}*/

		/*private Vector3 calculateTargetRot ()
		{
			Vector3 normalVector = _base.up.normalized;
			Vector3 distance = TargetDistance;
			float scalar = Vector3.Dot(normalVector, distance);
			return distance - normalVector * scalar;
		}*/

		private Quaternion getTargetRotation()
		{
			Vector3 upVector = (TargetPos - _center.position);
			Vector3 normalVector = upVector.normalized;
			Vector3 distance = upVector + TargetDistance;
			float scalar = Vector3.Dot(normalVector, distance);
			Vector3 foreward = distance - normalVector * scalar;
			foreward = foreward.normalized;
			//Debug.Log($"TargetPos: {TargetPos} | base pos: {_base.position}");
			//Debug.Log($"up: {upVector} | foreward: {foreward}");
			return Quaternion.LookRotation(foreward, upVector);

		}
	}
}