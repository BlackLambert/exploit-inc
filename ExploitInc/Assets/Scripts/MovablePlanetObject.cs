
using System;
using UnityEngine;

namespace SBaier.ExploitInc
{
	public class MovablePlanetObject :  Movable
	{
		[SerializeField]
		private float _speed = 0.1f;
		[SerializeField]
		private float _rotationSpeed = 1f;
		[SerializeField]
		private float _verticalSpeed = 0.1f;
		[SerializeField]
		private Transform _targetObject = null;
		[SerializeField]
		private Transform _center = null;

		private float _xRotation = 0;
		private float _yRotation = 0;
		private float _verticalDelta = 0;

		public override event Action TargetReached;

		public Vector3 Target { get; private set; }
		private Vector3 CenterToTarget => Target - _center.position;
		private Vector3 CenterToObject => _targetObject.position - _center.position;
		private Vector3 ObjectToTarget => Target - _targetObject.position;

		private bool MovementLeft => _xRotation != 0 || _yRotation != 0 || _verticalDelta != 0;

		public override void MoveTo(Vector3 target, bool immediatly = false)
		{
			initMovement(target);
			if (immediatly)
				jumpToTarget();
		}

		private void initMovement(Vector3 target)
		{
			Target = target;
			_xRotation = calculateXRotation();
			_yRotation = calculateYRotation();
			_verticalDelta = calculateVerticalDelta();
		}

		private void jumpToTarget()
		{
			if (!MovementLeft)
				return;
			rotateY(true);
			rotateX(true);
			moveVertical(true);
			checkFinishMovement();
		}

		public override void CancelMovement()
		{
			Target = Vector3.zero;
			_xRotation = 0;
			_yRotation = 0;
			_verticalDelta = 0;
		}

		private float calculateXRotation()
		{
			return Vector3.Angle(_center.up, CenterToTarget);
		}

		private float calculateYRotation()
		{
			Vector3 projection = Vector3.ProjectOnPlane(ObjectToTarget, _center.up);
			return Vector3.Angle(_center.forward, projection);
		}

		private float calculateVerticalDelta()
		{
			return CenterToTarget.magnitude - CenterToObject.magnitude;
		}


		protected virtual void FixedUpdate()
		{
			if (!MovementLeft)
				return;
			rotateY();
			rotateX();
			moveVertical();
			checkFinishMovement();
			//Debug.Log($"{name} rotating");
		}

		private void rotateY(bool immediatly = false)
		{
			if (_yRotation == 0)
				return;
			float factor = Vector3.Dot(_center.right, ObjectToTarget) > 0 ? 1 : -1;
			float delta = (immediatly ? _yRotation : _rotationSpeed);
			rotateArround(_center.up, _yRotation * factor, delta * factor);
			_yRotation = Mathf.Clamp(_yRotation - delta, 0, _yRotation);
		}

		private void rotateX(bool immediatly = false)
		{
			if (_yRotation != 0 || _xRotation == 0)
			//if (_xRotation == 0)
				return;
			float delta = immediatly ? _xRotation : _speed;
			//delta = Vector3.Dot(_center.forward, ObjectToTarget) > 0 ? _speed : -_speed;
			rotateArround(_center.right, _xRotation, delta);
			_xRotation = Mathf.Clamp(_xRotation - delta, 0, _xRotation);
		}

		private void moveVertical(bool immediatly = false)
		{
			if (_yRotation != 0 || _verticalDelta == 0)
				return;
			int factor = _verticalDelta > 0 ? 1 : -1;
			float delta = immediatly ? _verticalDelta :  Mathf.Min(_verticalSpeed, Mathf.Abs(_verticalDelta)) * factor;
			_verticalDelta -= delta;
			_targetObject.localPosition += new Vector3(0, delta, 0);
		}

		private void checkFinishMovement()
		{
			if (MovementLeft)
				return;
			TargetReached?.Invoke();
		}

		private void rotateArround(Vector3 axis, float maxRotation, float deltaRotation)
		{
			float delta = deltaRotation;
			if (Mathf.Abs(maxRotation) <= Mathf.Abs(deltaRotation))
				delta = maxRotation;
			_center.RotateAround(_center.position, axis, delta);
		}
	}
}