using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Zenject;

namespace SBaier.ExploitInc
{
	public class MovablePlanetObject : MonoBehaviour
	{
		[SerializeField]
		private float _speed = 0.1f;
		[SerializeField]
		private float _rotationSpeed = 1f;
		[SerializeField]
		private Transform _base = null;
		[SerializeField]
		private Transform _center = null;

		private float _xRotation = 0;
		private float _yRotation = 0;

		public Vector3 TargetPosition { get; private set; }
		private Vector3 CenterToTarget => TargetPosition - _center.position;
		private Vector3 ObjectToTarget => TargetPosition - _base.position;

		public void MoveTo(Vector3 point)
		{
			TargetPosition = point;
			_xRotation = calculateXRotation();
			_yRotation = calculateYRotation();
		}

		private float calculateXRotation()
		{
			return Vector3.Angle(_center.up, CenterToTarget);
		}

		private float calculateYRotation()
		{
			Vector3 projection = Vector3.ProjectOnPlane(ObjectToTarget, _center.up);
			return Vector3.Angle(_center.forward, projection);
		}


		protected virtual void FixedUpdate()
		{
			if (_yRotation != 0)
			{
				float factor = 1;
				factor = Vector3.Dot(_center.right, ObjectToTarget) > 0 ? 1 : -1;
				rotateArround(_center.up, _yRotation * factor, _rotationSpeed * factor);
				_yRotation = Mathf.Clamp(_yRotation - _rotationSpeed, 0, _yRotation);
			}
			else if (_xRotation != 0)
			{
				float delta = _speed;
				//delta = Vector3.Dot(_center.forward, ObjectToTarget) > 0 ? _speed : -_speed;
				rotateArround(_center.right, _xRotation, delta);
				_xRotation = Mathf.Clamp(_xRotation - _speed, 0, _xRotation);
			}
		}

		private void rotateArround(Vector3 axis, float maxRotation, float deltaRotation)
		{
			float delta = deltaRotation;
			if (Mathf.Abs(maxRotation) <= Mathf.Abs(deltaRotation))
				delta = maxRotation;
			_center.RotateAround(_center.position, axis, delta);
		}
	}
}