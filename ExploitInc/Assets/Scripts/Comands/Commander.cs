using System;
using Zenject;

namespace SBaier.ExploitInc
{
	public abstract class Commander<TCommandsContainer> where TCommandsContainer : CommandsContainer
	{
		protected TCommandsContainer _container;
		public Command CurrentCommand => _container.Current;

		[Inject]
		private void Construct(TCommandsContainer container)
		{
			_container = container;
		}


		public void AddCommand(Command command)
		{
			validateCommandToAdd(command);
			addCommand(command);
		}
		public void RemoveCommand(Command command)
		{
			validateCommandToRemove(command);
			removeCommand(command);
		}

		public void CancelCurrentCommand()
		{
			if (_container.Current == null | _container.Current.State == CommandState.Canceled)
				return;
			removeCommand(_container.Current);
		}

		protected virtual void validateCommandToAdd(Command command)
		{
			if (command == null)
				throw new ArgumentNullException();
			if (_container.Current == command)
				return;
			if (command is CommandSequence)
				validateCommandSequence((CommandSequence)command);
			else
				validateCommandType(command);
		}

		private void validateCommandSequence(CommandSequence sequence)
		{
			foreach (Command c in sequence.CommandsCopy)
				validateCommandToAdd(c);
		}

		protected virtual void validateCommandToRemove(Command command)
		{
			if (command == null)
				throw new ArgumentNullException();
			if (_container.Current != command)
				throw new ArgumentException();
		}


		protected internal abstract void removeCommand(Command command);
		protected internal abstract void addCommand(Command command);
		protected internal abstract void validateCommandType(Command command);
	}
}